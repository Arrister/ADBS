#1. Write a program to implement Abstract Data Types (ADT) in python
class Stack:
    def __init__(self):
        self.items = []
    def is_empty(self):
        return self.items == []
    def push(self, item):
        self.items.append(item)
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            raise IndexError("Pop from empty stack.")
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        else:
            raise IndexError("Peek from empty stack.")
    def size(self):
        return len(self.items)
if __name__ == "__main__":
    stack = Stack()
    print("Is the stack empty? ", stack.is_empty())
    stack.push(1)
    stack.push(2)
    stack.push(3)
    print("Size of Stack: ", stack.size())
    print("Top element of the stack: ", stack.peek())
    popped_item = stack.pop()
    print("Popped item: ", popped_item)
    print("Size of Stack after popping: ", stack.size())

#2. Write a program to implement Singly Linked list with insertion, deletion, traversal operations
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def is_empty(self):
        return self.head is None
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    def insert_at_end(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        current = self.head
        while current.next is not None:
            current = current.next
        current.next = new_node
    def delete(self, data):
        if self.head is None:
            raise Exception("Cannot delete from empty list")
        if self.head.data == data:
            self.head = self.head.next
            return
        current = self.head
        prev = None
        while current is not None:
            if current.data == data:
                prev.next = current.next
                return
            prev = current
            current = current.next
        raise ValueError("Data not found in the list")
    def display(self):
        current = self.head
        while current is not None:
            print(current.data, end=" -> ")
            current = current.next
        print("None")
if __name__ == "__main__":
    linked_list = SinglyLinkedList()
    linked_list.insert_at_beginning(1)
    linked_list.insert_at_end(2)
    linked_list.insert_at_end(3)
    linked_list.insert_at_end(4)
    print("Linked List:")
    linked_list.display()
    linked_list.delete(3)
    print("Linked List after deletion:")
    linked_list.display()

#3. Write a program to implement Doubly Linked list with insertion, deletion, traversal operations
class Node:
    def __init__(self,data):    
        self.data = data;    
        self.previous = None;    
        self.next = None;    
class DoublyLinkedList:        
    def __init__(self):    
        self.head = None;    
        self.tail = None;        
    def addNode(self, data): 
        newNode = Node(data);     
        if(self.head == None):        
            self.head = self.tail = newNode;        
            self.head.previous = None;     
            self.tail.next = None;    
        else:    
            self.tail.next = newNode;    
            newNode.previous = self.tail;    
            self.tail = newNode;    
            self.tail.next = None;        
    def display(self):        
        current = self.head;    
        if(self.head == None):    
            print("List is empty");    
            return;    
        print("Nodes of doubly linked list: ");    
        while(current != None):        
            print(current.data),;    
            current = current.next; 
dList = DoublyLinkedList();    
dList.addNode(1);    
dList.addNode(2);    
dList.addNode(3);    
dList.addNode(4);    
dList.addNode(5); 
print(dList.display())

#4. Write a program to implement Stack with insertion, deletion, traversal operations
class Stack:
    def __init__(self):
        self.items=[]
    def isEmpty(self):
        return self.items==[]
    def push(self,item):
        self.items.insert(0,item)
    def pop(self):
        return self.items.pop(0)
    def peek(self):
        return self.items[0]
    def size(self):
        return len(self.items)
    def getElements(self):
        return self.items
s=Stack()
s.push('Hello')
s.push('world')
s.push('10')
s.push('20')
print("The element of stack are:",s.getElements())  
print(s.pop())
print("The element of stack are:",s.getElements())

#5. Write a program to implement Queue with insertion, deletion, traversal operations.
class Queue:
    def __init__(self):
      self.qList=list()
      self.front=0
    def enqueue(self,item):  
        self.qList.append(item)
    def dequeue(self):
        if len(self.qList) == 0:
            print("cannot dequeue from an empty queue.")
        else:
            return self.qList.pop(0)
Q = Queue()
Q.dequeue()
Q.enqueue(28)
Q.enqueue(19)
Q.enqueue(45)
Q.enqueue(13)
Q.enqueue(7)
print("queue elements:",Q.qList)
Q.dequeue()
print("after removing element for queue",Q.qList)
Q.enqueue(77)	
print("queue element:",Q.qList)

#6. Write a program to implement Priority Queue with insertion, deletion, traversal operations.
class PriorityQueue(object):
    def __init__(self):
        self.queue = []
    def __str__(self):
        return ' '.join([str(i) for i in self.queue])
    def isEmpty(self):
        return len(self.queue) == 0
    def insert(self, data):
        self.queue.append(data)
    def delete(self):
        try:
            max_val = 0
            for i in range(len(self.queue)):
                if self.queue[i] > self.queue[max_val]:
                    max_val = i
            item = self.queue[max_val]
            del self.queue[max_val]
            return item
        except IndexError:
            print()
            exit()
if __name__ == '__main__':
    myQueue = PriorityQueue()
    myQueue.insert(12)
    myQueue.insert(1)
    myQueue.insert(14)
    myQueue.insert(7)
    print(myQueue)            
    while not myQueue.isEmpty():
        print(myQueue.delete())

#7. Write a program to implement Binary Tree with insertion, deletion, traversal operations
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key
def insert(root, key):
    if root is None:
        return TreeNode(key)
    else:
        if root.val < key:
            root.right = insert(root.right, key)
        else:
            root.left = insert(root.left, key)
    return root
def delete(root, key):
    if root is None:
        return root
    if key < root.val:
        root.left = delete(root.left, key)
    elif key > root.val:
        root.right = delete(root.right, key)
    else:
        if root.left is None:
            temp = root.right
            root = None
            return temp
        elif root.right is None:
            temp = root.left
            root = None
            return temp
        temp = minValueNode(root.right)
        root.val = temp.val
        root.right = delete(root.right, temp.val)
    return root
def minValueNode(node):
    current = node
    while current.left is not None:
        current = current.left
    return current
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.val, end=' ')
        inorder_traversal(root.right)
if __name__ == '__main__':
    root = None
    keys = [50, 30, 20, 40, 70, 60, 80]
    for key in keys:
        root = insert(root, key)
    print("Inorder traversal of the BST:")
    inorder_traversal(root)
    print()
    key_to_delete = 30
    print(f"Deleting node with key {key_to_delete}...")
    root = delete(root, key_to_delete)
    print("Inorder traversal after deletion:")
    inorder_traversal(root)
    print()

#8. Write a program to implement Huffman Coding
import heapq
class Node:
    def __init__(self, symbol=None, frequency=None):
        self.symbol = symbol
        self.frequency = frequency
        self.left = None
        self.right = None
    def __lt__(self, other):
        return self.frequency < other.frequency
def build_huffman_tree(chars, freq):
    priority_queue = [Node(char, f) for char, f in zip(chars, freq)]
    heapq.heapify(priority_queue)
    while len(priority_queue) > 1:
        left_child = heapq.heappop(priority_queue)
        right_child = heapq.heappop(priority_queue)
        merged_node = Node(frequency=left_child.frequency + right_child.frequency)
        merged_node.left = left_child
        merged_node.right = right_child
        heapq.heappush(priority_queue, merged_node)
    return priority_queue[0]
def generate_huffman_codes(node, code="", huffman_codes={}):
    if node is not None:
        if node.symbol is not None:
            huffman_codes[node.symbol] = code
        generate_huffman_codes(node.left, code + "0", huffman_codes)
        generate_huffman_codes(node.right, code + "1", huffman_codes)
    return huffman_codes
chars = ['a', 'b', 'c', 'd', 'e', 'f']
freq = [4, 7, 15, 17, 22, 42]
root = build_huffman_tree(chars, freq)
huffman_codes = generate_huffman_codes(root)
for char, code in huffman_codes.items():
    print(f"Character: {char}, Code: {code}")

#9. Write a program to implement Graph with insertion, deletion, traversal operations.
print("Enter details of graph")
x=int(input("Enter no of nodes"))
a=[[0 for i in range(6) ] for j in range(6)]
print("Insert node vise edges")
for i in range(0,x):
    print("enter no of edge coming out from node",i)
    y=int(input("no of edges"))
    for j in range(0,y):
        ed=int(input("End node"))
        a[i] [ed]=1
    print("\n")
print("Adjacancy Matrix")
for i in range(0,x):
    for j in range(0,x):
        print(a[i][j], end="")
    print(end="\n")

#10. Write a program to implement Travelling Salesman Problem.
import heapq
class Graph:
    def __init__(self):
        self.nodes = set()
        self.edges = {}
        self.distances = {}
    def add_node(self, value):
        self.nodes.add(value)
    def add_edge(self, from_node, to_node, distance):
        self.edges.setdefault(from_node, []).append(to_node)
        self.edges.setdefault(to_node, []).append(from_node)
        self.distances[(from_node, to_node)] = distance
        self.distances[(to_node, from_node)] = distance
    def dijkstra(self, initial_node):
        distances = {node: float('infinity') for node in self.nodes}
        distances[initial_node] = 0
        priority_queue = [(0, initial_node)]
        while priority_queue:
            current_distance, current_node = heapq.heappop(priority_queue)
            if current_distance > distances[current_node]:
                continue
            for neighbor in self.edges.get(current_node, []):
                distance = current_distance + self.distances[(current_node, neighbor)]
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(priority_queue, (distance, neighbor))
        return distances
if __name__ == "__main__":
    graph = Graph()
    graph.add_node('A')
    graph.add_node('B')
    graph.add_node('C')
    graph.add_node('D')
    graph.add_node('E')
    graph.add_edge('A', 'B', 1)
    graph.add_edge('A', 'C', 4)
    graph.add_edge('B', 'C', 2)
    graph.add_edge('B', 'D', 5)
    graph.add_edge('C', 'D', 1)
    graph.add_edge('C', 'E', 3)
    graph.add_edge('D', 'E', 7)
    shortest_paths = graph.dijkstra('A')
    for node, distance in shortest_paths.items():
        print(f"Shortest path from A to {node}: {distance}")